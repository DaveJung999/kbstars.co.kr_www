*** Update File: Admin_basketball/sthis_house/download.php
@@
//		mode=watermark	: 워터마크 처리함
//		mode=allimages	: 이미지들을 html문서로 모두 보여줌
//						="download.php?mode=allimages&db={$db}&uid={$uid}";
-$HEADER=array(
+// 이미지 모드일 때는 출력 버퍼를 먼저 시작하여 header.php의 출력을 캡처
+if (isset($_GET['mode']) && ($_GET['mode'] == 'image' || $_GET['mode'] == 'thumbnail' || $_GET['mode'] == 'watermark' || $_GET['mode'] == 'mainimage')) {
+	@ob_start();
+}
+$HEADER=array(
 		'priv' =>	"운영자,뉴스관리자", // 인증유무 (0:모두에게 허용, 숫자가 높을 수록 레벨업)
 		'usedb2' => 1, // DB 커넥션 사용 (0:미사용, 1:사용)
 		'useBoard2' => 1, // privAuth()
@@
//================================== 
// 파일 읽어서 브라우저에 바로 보내기
//================================== 
unset($dbinfo);
unset($list);
// mime-type 결정
+
+// 이미지 바이너리 앞에 텍스트가 섞이면 브라우저가 이미지로 인식하지 못함
+if (function_exists('ob_get_level')) {
+	// 모든 출력 버퍼를 완전히 비움
+	while (ob_get_level() > 0) {
+		@ob_end_clean();
+	}
+}
+// 추가로 출력 버퍼링을 완전히 비활성화
+@ini_set('output_buffering', 'off');
+@ini_set('zlib.output_compression', false);
+
+// 헤더 전송 전에 출력이 있는지 확인하고 완전히 제거
+if (ob_get_level() > 0) {
+	@ob_end_clean();
+}
 
 if(function_exists('mime_content_type')) header('Content-type: '.mime_content_type($filepath));
 else {
@@
 				
 //메모리 문제 발생되면 아래 방식으로
 while(!feof($fd)){
 	print fread($fd, 4096);
 }
 fclose($fd);
@@
 		header( "Content-Length: ".filesize( $file));
 		header( "Content-Description: File Transfert");
 		@readfile( $file);
 		exit();
 */
-$fd=fopen($filepath,'rb');
-fpassthru($fd);
+//==================================
+// JPEG 파일 앞에 개행(0x0A) 등 불필요한 바이트가 붙어 있는
+// 예전 데이터가 존재하여, 브라우저에서 X박스로 보이는 문제가 있어
+// 실제 전송 시에는 파일 내에서 JPEG SOI(0xFF 0xD8)를 찾아
+// 그 이전 바이트는 모두 무시하고 이후만 전송한다.
+// - 디스크의 원본 파일은 변경하지 않는다.
+//==================================
+$fd = fopen($filepath, 'rb');
+if ($fd) {
+	// 앞부분 버퍼를 읽어서 SOI 위치를 찾는다 (최대 4KB 내에서)
+	$buffer = '';
+	while (!feof($fd) && strlen($buffer) < 4096) {
+		$chunk = fread($fd, 512);
+		if ($chunk === false || $chunk === '') break;
+		$buffer .= $chunk;
+		// SOI를 찾으면 더 이상 읽지 않음
+		if (strpos($buffer, "\xFF\xD8") !== false) break;
+	}
+
+	$pos = strpos($buffer, "\xFF\xD8");
+	if ($pos === false) {
+		// SOI를 찾지 못하면 원본 그대로 전송
+		rewind($fd);
+		fpassthru($fd);
+	} else {
+		// SOI 이후부터 출력
+		echo substr($buffer, $pos);
+		// 나머지 전체 전송
+		while (!feof($fd)) {
+			$out = fread($fd, 8192);
+			if ($out === false || $out === '') break;
+			echo $out;
+		}
+	}
+	fclose($fd);
+}
